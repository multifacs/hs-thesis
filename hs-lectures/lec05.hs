import Prelude hiding (foldr, foldl, length, map, maximum)

-------------------------------------------------
-- Конспект лекции 5 от 06.03.2023
-------------------------------------------------

-- Содержание

-- 1. Левая и правая свертки
-- 2. Лямбда-исчисление с простыми типами
-- 3. Параметрический полиморфизм
-- 4. Определение типов подвыражений и нахождение типовых ошибок
-- 5. Домашнее задание

-------------------------------------------------
-- 1. Левая и правая свертки
-------------------------------------------------

foldr :: (a -> b -> b) -> b -> [a] -> b
foldr f z [] = z
foldr f z (x:xs) = f x (foldr f z xs)

-- foldr f z [1, 2, 3] =
-- f 1 (foldr f z [2, 3]) =
-- f 1 (f 2 (foldr f z [3]))
-- f 1 (f 2 (f 3 (foldr f z [])))
-- f 1 (f 2 (f 3 z)) =
-- 1 `f` (2 `f` (3 `f` z))

-- f получает два аргумента. Первый — это голова списка. Второй —
-- результат обработки хвоста списка. Задача f — превратить
-- результат обработки хвоста (рекурсивный вызов) в результат
-- обработки всего списка.

-- foldr использует нехвостовую рекурсию.

foldl :: (b -> a -> b) -> b -> [a] -> b
foldl f z [] = z
foldl f z (x:xs) = foldl f (f z x) xs

-- foldl f z [1, 2, 3] =
-- foldl f (f z 1) [2, 3] =
-- foldl f (f (f z 1) 2) [3] =
-- foldl f (f (f (f z 1) 2) 3) [] =
-- (f (f (f z 1) 2) 3) =
-- ((z `f` 1) `f` 2) `f` 3

-- foldl использует хвостовую рекурсию.

-- length через foldr

-- x есть голова списка
-- y есть длина хвоста

length = foldr (\x y -> y+1) 0

-- Обратите внимание, что (\x y -> y+1) == const (+1), а
-- (\x y -> x+1) == const . (+1) (домашнее задание 4).
-- Объясните эти равенства функций.

-- (++) через foldr

-- Напоминание определения конкатенации двух списков (++).

-- [] ++ l2 = l2
-- (h : t) ++ l2 = h : (t ++ l2)

append l1 l2 = foldr (\h p -> h : p) l2 l1

-- Более коротко:

append' l1 l2 = foldr (:) l2 l1

append'' = flip $ foldr (:)

-- map через foldr

map' f l = foldr (\h p -> f h : p) [] l

-- l можно опустить из левой и правой части.

-- Обратите внимание на порядок аргументов функции f, являющейся
-- первым аргументом foldr и foldl. В foldr элемент списка является
-- первым аргументом, а в foldl — вторым. Если `f` используется как
-- инфиксный оператор, то элемент списка является левым аргументом `f`
-- в foldr и правым — в foldl. Это соответствует расстановке скобок.

-- В Prelude имеются функции foldl1 и foldr1, похожие на foldl и
-- foldr, но которые работают на непустых списках и используют
-- крайние элементы списка как начальное значение. Из-за этого
-- результат функции имеет тот же тип, что и элементы списка. Это не
-- обязательно верно для foldl и foldr.

-- Замечание: реальные типы функций foldr и т.п. в Prelude более общие.

-- foldr :: (a -> b -> b) -> b -> [a] -> b
-- foldl :: (b -> a -> b) -> b -> [a] -> b
-- foldr1 :: (a -> a -> a) -> [a] -> a
-- foldr1 :: (a -> a -> a) -> [a] -> a

-- Пример: maximum не определен на пустом списке, поэтому используем foldl1.

maximum :: Ord a => [a] -> a
maximum = foldl1 max

-- Вычисление foldl продолжается, пока не закончится весь список,
-- потому что foldl не может взаимодействовать с окружающей функцией.
-- При этом размер второго аргумент foldl растет с каждым вызовом. Он
-- не упрощается из-за ленивой стратегии. Поэтому если третий аргумент
-- foldl является бесконечным списком, то при выполнении произойдет
-- переполнение памяти, несмотря на то, что foldl реализована с
-- помощью хвостовой рекурсии.

-- В модуле Data.Foldable есть функция foldl' с тем же типом, что и
-- foldl, которая в отличие от foldl использует энергичную стратегию
-- для вычисления своего второго аргумента. Это значит, что образом,
-- второй аргумент foldl' упрощается перед вызовом самой функции.
-- Таким образом, если foldl' вызывается на бесконечном списке, то
-- вычисление не закончится, но и переполнения памяти не произойдет.

-- В отличие от этого вычисление foldr на бесконечном списке может
-- закончиться, если функция f, являющаяся первым аргументом, не
-- обязательно использует свой второй аргумент. Например, функцию,
-- возвращающую произведение элементов списка, можно определить
-- следующим образом.

product0 :: [Int] -> Int
product0 = foldr step 1 where
  step 0 _ = 0
  step x y = x * y

-- Тогда product0 [5, 4 ..] возвращает 0. Вычисление foldr f z xs
-- также закончится на бесконечном xs, если f x p возвращает выражение
-- вида a : b, где p используется только в b, а окружающий контекст
-- foldr f z xs требует только конечное число элементов списка. Так,
-- например, заканчивается вычисление take 5 $ map' (+1) [0..], где
-- map' определена выше.

-------------------------------------------------
-- 2. λ-исчисление с простыми типами
-------------------------------------------------

-- Термы определяются грамматикой m ::= x | m m | λx. m.

-- Термы вида m n называются аппликацией, а λx. m —
-- (λ-)абстракцией. Терм λx. m определяет анонимную
-- функцию с формальным параметром (аргументом) x и телом m.

-- Аппликации группируется налево: m n k есть (m n) k.
-- λx y. m есть сокращение для λx. λy. m.

-- Переменная x считается связанной в терме λx. m. Переменные, у
-- которых есть хотя бы одно несвязанное вхождение в терме, называются
-- свободными. Связанные переменные можно свободно переименовывать.
-- Это называется α-конверсией. В этом смысле выражение λx. m
-- ведет себя во многом также, как ∀x. m или ∃x. m.

-- В Haskell вместо λx y z. m пишется \x y z -> m.

-- m[n/x] обозначает подстановку терма n в терм m вместо свободных
-- вхождений переменной x.

-- Типы определяются грамматикой a ::= b | a -> a. Здесь b пробегает
-- по множество базовых типов, например, Bool, Int, String.
-- Пример типа: (Int -> Bool) -> String.

-- Не все термы бестипового исчисления имеют смысл с точки зрения типов.
-- Например, x x есть терм, но если x представляет функцию из a в
-- b, то аргумент x должен иметь тип a, что приводит к уравнению на
-- типы a -> b = a. У этого уравнения нет конечных решений.

-- Правила типизации

-- Контекст Γ есть последовательность x1 : a1, x2 : a2, ..., xn : an,
-- где xi — переменные, ai — типы. Для исчисления с простыми типами
-- контекст можно также рассматривать как множество, на для более
-- выразительных типов порядок переменных важен.

-- Выводимые суждения имеют вид Γ |- M : a, где M — терм, a — тип. Для
-- правил ниже выполняется утверждение: если Γ |- M : a выводится, то
-- все свободные переменные терма M встречаются в Γ. Смысл: если
-- свободные переменные в M имеют типы, как указано в Γ, то терм M
-- имеет тип a.

-- Аксиома

-- Γ, x : a |- x : a (Var)

-- Правила вывода

--    Γ, x : a |- M : b
-- -------------------------------- (Abs)
-- Γ |- (λx. M) : a -> b

-- Γ |- M : a -> b    Γ |- N : a
-- ------------------------------ (App)
--          Γ |- M N : b

-- Пример 1

--   --------------- (Var)
--    x : a |- x : a
-- ----------------------- (Abs)
-- |- (λx. x) : a -> a

-- Проверка: наберите :t \x -> x в интерпретаторе.

-- Пример 2

--    --------------------- (Var)
--    x : a, y : b |- x : a
--   ---------------------------- (Abs)
--    x : a |- (λy : b. x) : b -> a
-- ------------------------------------ (Abs)
-- |- (λx. λy. x) : a -> b -> a

-- Проверка: наберите :t \x -> \y -> x.

-- Пример 3

-- В этом выводе Γ обозначает контекст f : b -> c, g : a -> b, x : a.

--                             --------------- (Var)  ---------- (Var)
--                             Γ |- g : a -> b       Γ |- x : a
--     --------------- (Var)   -------------------------------- (App)
--      Γ |- f : b -> c              Γ |- g x : b
--     -------------------------------------------- (App)
--     f : b -> c, g : a -> b, x : a |- f (g x) : c
--   ---------------------------------------------------- (Abs)
--     f : b -> c, g : a -> b |- λx. f (g x) : a -> c
-- --------------------------------------------------------------- (Abs)
-- f : b -> c |- λg. λx. f (g x) : (a -> b) -> a -> c
-- --------------------------------------------------------------- (Abs)
-- |- λf. λg. λx. f (g x) : (b -> c) -> (a -> b) -> a -> c

-- Проверка: наберите :t \f g x -> f (g x).

-------------------------------------------------
-- 3. Параметрический полиморфизм
-------------------------------------------------

-- Нaskell использует обобщение простых типов. Так, в Haskell есть
-- параметрический полиморфизм. Типы могут содержать переменные, и в
-- начале типа должны стоять неявные кванторы всеобщности по этим
-- переменным. Например,

-- length :: [a] -> Int

-- означает на самом деле ∀a. [a] -> Int, то есть вместо a может быть
-- подставлен любой тип. Любая такая подстановка дает правильный тип
-- функции length. Так, [Int] -> Int, [Bool] -> Int, [String -> Float] -> Int
-- все являются типами length. В этом можно убедиться в командной строке.

-- > :t length :: [Bool] -> Int
-- length :: [Bool] -> Int :: [Bool] -> Int

-- Здесь length :: [Bool] -> Int — выражение, а не объявление
-- функции. Такое приведение типа может использоваться в разных
-- контекстах.

-------------------------------------------------
-- 4. Определение типов подвыражений и нахождение типовых ошибок
-------------------------------------------------

-- В Prelude есть функция (бесточечная запись)

-- concatMap :: (a -> [b]) -> [a] -> [b]
-- concatMap f = concat . map f

-- Например, concatMap (replicate 3) "abc" = "aaabbbccc".

-- Следующая функция должна делать то же самое, но проходить
-- исходный список в обратном порядке. То есть
-- reverseConcatMap (replicate 3) "abc" = "cccbbbaaa".

-- Рассмотрим следующее ошибочное определение.

-- reverseConcatMap :: (a -> [b]) -> [a] -> [b]
-- reverseConcatMap f = foldl (flip . (++) . f) []

-- С учетом типа функции выпишем типы всех подвыражений правой
-- части определения.

-- Как было сказано выше, переменные a и b в типе reverseConcatMap
-- пробегают по произвольным типам. Фиксируем a и b, и типы остальных
-- подвыражений напишем через них. Важно: тип каждого подвыражения не
-- обязательно являются наиболее общим. Он такой, какой требуется для
-- типизации всего выражения.

-- Из типа функции видно, что

-- f :: a -> [b]

-- Для того, чтобы (++) . f имело смысл, область значений f должна
-- совпадать с областью определния (++). Поэтому в данной задаче
-- неправильно написать (++) :: [a] -> [a] -> [a]. Это верно в том
-- смысле, что (++) :: ∀a. [a] -> [a] -> [a]. Однако при
-- фиксированных a и b из типа reverseConcatMap вхождение функции (++)
-- уже не может иметь тип [a] -> [a] -> [a].

-- (++) :: [b] -> [b] -> [b]
-- (++) . f :: a -> [b] -> [b]

-- Теперь становится видно, что с учетом типа flip:

-- flip :: ∀a b c. (a -> b -> c) -> b -> a -> c

-- выражение flip . ((++) . f) не типизируемо. Действительно, (++) . f
-- возвращает значения типа [b] -> [b], то есть функции одного
-- аргумента, а flip ожидает функцию двух аргументов.

-- Скорее всего, вместо flip . (++) . f имелось в виду
-- flip $ (++) . f. Тогда имеем:

-- flip $ (++) . f :: [b] -> a -> [b]
-- foldl :: ([b] -> a -> [b]) -> [b] -> [a] -> [b]

-- Здесь снова нельзя написать тип foldl, который печатает Haskell:

-- foldl :: (b -> a -> b) -> b -> [a] -> b

-- потому что это наиболее общий тип. В данном определении
-- тип foldl есть некоторый частный случай этого общего типа.

-- foldl (flip $ (++) . f) :: [b] -> [a] -> [b]
-- foldl (flip $ (++) . f) [] :: [a] -> [b]

-- Итак, правильное определение имеет вид

reverseConcatMap :: (a -> [b]) -> [a] -> [b]
reverseConcatMap f xs = foldl (flip $ (++) . f) [] xs

-------------------------------------------------
-- 5. Домашнее задание
-------------------------------------------------

-- 1. Выразите функции elem и filter через foldr.

-- 2. Используя foldr и не используя явно рекурсию, напишите функцию
-- composeAll :: [a -> a] -> (a -> a), берущую список функций и
-- возвращающая их последовательную композицию (функция, являющаяся
-- головой списка, применяется последней). Например, composeAll [(^2),
-- (*2), (+3)] 0 = 36.

-- 3. С помощью foldl или foldr напишите функцию horner :: [Double] ->
-- Double -> Double, которая с помощью метода Горнера (см. Википедию)
-- вычисляет значение полинома, заданного списком своих коэффициентов,
-- на втором аргументе.

-- 4. Выразите reverse через (:) и foldl.

-- 5. Не используя явно рекурсию, напишите функцию findIndices :: (a ->
-- Bool) -> [a] -> [Int], находящую индексы тех элементов в списке, на
-- которых условие возвращает True. Можно использовать библиотечные
-- функции.

-- 6. Для каждого из следующих типов напишите какой-нибудь терм,
-- имеющий этот тип.

-- (a -> a) -> a -> a
-- (a -> b) -> a -> b
-- ((a -> b) -> a) -> (a -> b) -> b
-- ((a -> b) -> (b -> c)) -> (a -> b) -> a -> c
-- ((a -> b) -> b -> c) -> (a -> b) -> a -> c

-- 7. Объясните следующую реализацию map.

map :: (a -> b) -> [a] -> [b]
map f = foldr ((:) . f) []

-- Для каждого из следующих подвыражений напишите тип, который это
-- подвыражение принимает в определении выше.

-- f :: a -> b
-- (:) :: b -> ([b] -> [b])
-- (.) :: (b -> ([b] -> [b])) -> (a -> b) -> a -> ([b] -> [b])
-- (.) (:) f == (:) . f :: a -> [b] -> [b]
-- foldr :: (a -> [b] -> [b]) -> [b] -> [a] -> [b]
-- foldr ((:) . f) :: [b] -> [a] -> [b]
-- foldr ((:) . f) [] :: [a] -> [b]

-- 8. По аналогии с задачей 2 объясните, как работает функция
-- reverseConcatMap, определенная на лекции.
