import Prelude hiding (elem, filter, reverse, map)

-------------------------------------------------
-- Конспект лекции 6 от 20.03.2023
-------------------------------------------------

-- См. также "Лекции по функциональному программированию" на
-- source.unn.ru.

-- Содержание
-- 1. Редукции и конверсии в λ-исчислении
-- 2. Решение некоторых задач из домашнего задания 5

-------------------------------------------------
-- 1. Редукции и конверсии в λ-исчислении
-------------------------------------------------

-- В λ-исчислении есть две основных редукции.

-- β-редукция: терм (\x -> m) n редуцируется (переписывается) к
-- результату подстановки n вместо x в m. Это подстановка фактического
-- параметра вместо формального в тело функции при ее вызове.

-- η-редукция: \x -> m x редуцируется к m, если x не входит свободно в m.
-- Действительно, эти два терма ведут себя одинаково, когда
-- выступают в роли функции: ((\x -> m x) n) β-редуцируется к
-- результату подстановки n вместо x в m x, то есть в m n
-- (здесь используется то, что x не входит свободно в m).

-- Обе эти редукции можно совершать не только на верхнем уровне,
-- но и в глубине терма.

-- Если есть две лямбда-абстракции: \x -> \y -> m x y =η \x -> m x =η m.
-- В общем случае \x1 ... xn -> m x1 ... xn =η m.

-- Выражение вида (\x -> m) n называется β-редексом (от reducible
-- expression). Аналогично выражение вида \x -> m x, где x не входит
-- свободно в m, называется η-редексом. Про терм, который не содержит
-- редексов, говорят, что он находится в нормальной форме.

-- Таким образом, редукции являются бинарными отношениями на множестве
-- термов. Назовем β- и η-конверсиями, или β- и η-равнствами,
-- рефлексивные, симметричные и транзитивные замыкания соответствующих
-- редукций. (Эта терминология нексолько отличается в разных
-- учебниках.) Таким образом, два терма называются β-равными, если один
-- получается из другого с помощью конечной цепочки β-редукций в ту
-- или другую сторону. β- и η-равенства обозачаются =β и =η,
-- соответственно. Их объединение обозначается =βη. Однако часто будет
-- записываться просто =.

-- Если m =βη n и n находится в нормальной форме, то n называется
-- нормальной формой терма m.

-- Кроме того, как было сказан выше, α-конверсия позволяет
-- переимновывать связанные переменные. Обычно α-равные термы
-- считаются одним и тем же термом.

-- η-равенство ответствено за бесточечную запись. Например, (++) можно
-- определить следующим образом.

append l1 l2 = foldr (\h p -> h : p) l2 l1

-- Однако \p -> h : p = \p -> ((:) h) p =η (:) h. Далее,
-- \h -> \p -> h : p =η \h -> (:) h =η (:). Поэтому append можно
-- переписать следующим образом.

-- append l1 l2 = foldr (:) l2 l1

-- то есть

-- append = \l1 l2 -> foldr (:) l2 l1

-- К этому терму η-редукцию неприменима. Однако если переставить
-- аргументы, то полученный терм можно сократить.

-- \l2 l1 -> foldr (:) l2 l1 =η foldr (:),

-- поэтому можно написать append = flip $ foldr (:).

-- Докажем некоторые равенства с помощью конверсий.

-- Домашнее задание 4, задача 2(1)

-- \x y -> x+1  =  const . (+1)

-- const . (+1) = (.) const (+1)
-- =  (\f g x -> f (g x)) const (+1) по определению (.)
-- =β \x -> const ((+1) x)
-- =  \x -> (\x y -> x) ((+1) x)     по определению const
-- =β \x y -> ((+1) x)
-- =  \x y -> ((\x -> x+1) x)        по определению (+1)
-- =β \x y -> x+1.

-- Домашнее задание 4, задача 2(2)

-- \x y = y x  и  flip id

-- flip id = (\f x y -> f y x) (\x -> x) по определению flip и id
-- =β \x y -> (\x -> x) y x
-- =β \x y -> y x

-- Лекция 5

-- (\x y -> y+1) = const (+1)

-- const (+1) = (\x y -> x) (+1)    по определению const
-- =β \y -> (+1)
-- =  \y -> \x -> x+1               по определению (+1)
-- =α \x y -> y+1

----------------------------------------------------
-- 2. Решение некоторых задач из домашнего задания 5
----------------------------------------------------

-- 1. Выразите функции elem и filter через foldr.

elem :: Eq a => a -> [a] -> Bool
elem x = foldr (\y z -> x == y || z) False

filter :: (a -> Bool) -> [a] -> [a]
filter p = foldr (\x y -> if p x then x : y else y) []

-- 2. Используя foldr и не используя явно рекурсию, напишите функцию
-- composeAll :: [a -> a] -> (a -> a), берущую список функций и
-- возвращающая их последовательную композицию (функция, являющаяся
-- головой списка, применяется последней). Например, composeAll [(^2),
-- (*2), (+3)] 0 = 36.

-- composeAll fs = foldr (\f -> \comp -> f . comp) id fs

-- Здесь f есть голова списка, а comp есть композиция функций из
-- хвоста списка. Это необычная рекурсия, так как она определяет
-- значение функционального типа. Так, базой является функция
-- id :: a -> a, и каждый рекурсивный вызов foldr также возвращает
-- функцию типа a -> a. В языках функционального программирования
-- рекурсия может вестить по любыми типам.

-- Более компактное решение:

composeAll :: [a -> a] -> (a -> a)
composeAll = foldr (.) id

-- Это решение получается следующим образом.

-- \f -> \comp -> f . comp
-- = \f -> \comp -> (.) f comp
-- =η \f -> (.) f
-- =η (.)

-- \fs -> foldr (.) id fs =η foldr (.) id

-- Это определение использует бесточечную запись.

-- 3. С помощью foldl или foldr напишите функцию horner :: [Double] ->
-- Double -> Double, которая с помощью метода Горнера (см. Википедия)
-- вычисляет значение полинома, заданного списком своих коэффициентов,
-- на втором аргументе.

-- Пусть старший коэффициент находится в начале списка, а младший — в конце.

horner :: [Double] -> Double -> Double
horner poly x = foldl (\p a -> p * x + a) 0 poly

-- 4. Выразите reverse через (:) и foldl.

reverse :: [a] -> [a]
reverse = foldl (flip (:)) []

-- 5. Не используя явно рекурсию, напишите функцию findIndices :: (a ->
-- Bool) -> [a] -> [Int], находящую индексы тех элементов в списке, на
-- которых условие возвращает True. Можно использовать библиотечные
-- функции.

findIndices :: (a -> Bool) -> [a] -> [Int]
findIndices pred lst = map fst $ filter (pred . snd) $ zip [0..] lst

-- 6. Для каждого из следующих типов напишите какой-нибудь терм,
-- имеющий этот тип.

-- \f\x. f x : (a -> a) -> a -> a

-- Здесь f : a -> a и x : a.

-- \f\x. f x : (a -> b) -> a -> b

-- Это тот же терм. Здесь f : a -> b и x : a.

-- \x\y. y (x y) : ((a -> b) -> a) -> (a -> b) -> b

-- x : (a -> b) -> a
-- y : a -> b
-- x y : a
-- y (x y) : b

-- \x y z. x y (y z) : ((a -> b) -> (b -> c)) -> (a -> b) -> a -> c
--  
-- x : (a -> b) -> (b -> c)
-- y : a -> b
-- z : a
-- x y : b -> c
-- y z : b

-- 7. Объясните следующую реализацию map.

map :: (a -> b) -> [a] -> [b]
map f = foldr ((:) . f) []

-- Следующая реализация должна быть понятна.

-- map f lst = foldr (\x y -> f x : y) [] lst
--  
-- Покажем, что реализация выше с ней совпадает. Рассмотрим выражение
-- ((:) . f).
--  
-- (:) отображает h в \t -> h : t.
--  
-- Композиция (:) . f отображает x в f x и затем отображает f x в \y -> f x : y.
-- Значит, (:) . f есть \x -> \y -> f x : y.

-- Формально:
-- (:) . f
-- = (.) (:) f
-- = (\f g x. f (g x)) (:) f
-- =β (\g x. (:) (g x)) f
-- =β \x. (:) (f x)
-- =η \x\y. (:) (f x) y
-- = \x\y. f x : y

-- Аргумент lst можно убрать из левой и правой части по η-редукции.

-- Для каждого из следующих подвыражений напишите тип, который это
-- подвыражение принимает в определении выше.

-- f :: a -> b
-- (:) :: b -> [b] -> [b]
-- (.) :: (b -> [b] -> [b]) -> (a -> b) -> a -> [b] -> [b]
-- (:) . f :: a -> [b] -> [b]
-- foldr :: (a -> [b] -> [b]) -> [b] -> [a] -> [b]
-- foldr ((:) . f) :: [b] -> [a] -> [b]
-- foldr ((:) . f) [] :: [a] -> [b]
