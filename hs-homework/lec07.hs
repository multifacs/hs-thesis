{-# LANGUAGE GADTs #-}

import Prelude hiding (not, lookup, Monoid)

-------------------------------------------------
-- Конспект лекции 7 от 20.03.2023
-------------------------------------------------

-- Содержание

-- 1. Классы типов
-- 2. Алгебраические типы
-- 3. Синонимы типов (type) и обертки вокруг типов (newtype)
-- 4. Бинарные операторы
-- 5. Объявление классов типов и их экземпляров
-- 6. Домашнее задание

-------------------------------------------------
-- 1. Классы типов
-------------------------------------------------

-- Прочитайте разделы 1.4 и 1.5 (с. 18–20) про классы типов в книге
-- А. Холомьёва «Учебник по Haskell»
-- http://anton-k.github.io/ru-haskell-book/book/home.html
-- (эта ссылка есть на source.unn.ru).

-- Прочитайте описание функций show и read на с. 43-45 в книге
-- Г.А. Макеева «Основы функционального программирования на языке
-- Haskell» http://ru-declarative.livejournal.com/109716.html
-- (эта ссылка также есть на source.unn.ru).
-- Этот материал пересекается с описанием в книге Холомьёва.

-- Рассмотрим следующий тип.

-- elem :: Eq a => a -> [a] -> Bool

-- Возможность подставлять вместо переменной a произвольные типы,
-- являющиеся членами класса Eq, называется полиморфизмом, основанном
-- на классах типов.

-- Одно и то же выражение может иметь разные типы.

-- read "54" :: Int
-- read "54" :: Integer
-- read "54" :: Float

-- Это тоже полиморфизм. В данном случае все эти типы числовые, но
-- в общем случае они могут быть совершенно разными.

-------------------------------------------------
-- 2. Алгебраические типы
-------------------------------------------------

-- Дальнейший материал про алгебраические типы данных (algebraic
-- datatypes) также содержится в книге Макеева на с. 66–74.

-- Напоминание: Bool — стандартный тип.

-- data Bool = False | True

-- Каждый тип имеет конструкторы, служащие для создания значений этого
-- типа, и деструкторы, служащие для анализа значений. Например, False
-- и True — конструкторы типа Bool. Типы и конструкторы пишутся с
-- большой буквы.

-- Аналог enum в С и Java

data Piece = Pawn | Rook | Knight | Bishop | Queen | King

-- Типы и конструкторы могут иметь одинаковое имя.

data SameName = SameName

data Day = Day Int deriving Show

-- Day :: Int -> Day

tomorrow :: Day -> Day
tomorrow (Day x) = Day $ (x + 1) `mod` 7

-- Здесь SameName :: SameName

-- Пустой кортеж () :: ()

-- Конструкторы могут использоваться как образцы в определении функции.
-- Так реализуются деструкторы.

not :: Bool -> Bool
not True = False
not False = True

-- Конструктор с аргументами: точка в двумерном пространстве.

data Point = Pt Float Float deriving Show

-- Pt :: Float -> Float -> Point

px :: Point -> Float
px (Pt x _) = x

-- Именованные поля (записи)

data Point2D = P2D {p1 :: Float, p2 :: Float} deriving Show

-- То же, что data Point2D = P2D Float Float,
-- но автоматически генерируются проекторы

-- p1 :: Point2D -> Float
-- p1 (P2D x1 x2) = x1

-- p2 :: Point2D -> Float
-- p2 (P2D x1 x2) = x2

point1 :: Point2D
point1 = P2D 1.0 2.0

point2 :: Point2D
point2 = P2D {p2 = 2.0, p1 = 1.0} -- поля можно задавать в любом порядке

-- Создание новой записи, которая отличается значением p1

point3 :: Point2D
point3 = point1 {p1 = 3.0}

-- Тип Maybe в Prelude для функций, которые могут не возвращать значение

-- data  Maybe a  =  Nothing | Just a deriving (Eq, Ord)

-- Пример использования: функция lookup (есть в Prelude)

lookup :: Eq a => a -> [(a,b)] -> Maybe b
lookup key [] = Nothing
lookup key ((k,v) : dict)
  | key == k = Just v
  | otherwise = lookup key dict

-- data Either a b  = Left a | Right b deriving (Eq, Ord, Read, Show)

-- Часто используется для возвращения полезного значения Right v
-- или сообщения об ошибке Left "error message".

-- Рекурсивные (индуктивные) типы

-- Унарное представление натуральных чисел (как в арифметике Пеано)

data Nat = Zero | Succ Nat deriving Show

-- Nat — это тип. Zero и Succ — его конструкторы. Zero — это
-- константа, а Succ (от слова successor) принимает один аргумент типа
-- Nat. Директива deriving Show автоматически объявляет членство Nat в
-- классе Show. Таким образом, значения Nat можно печатать в
-- интерпретаторе. Если требуется членство в нескольких классах, их
-- надо заключать в круглые скобки.

one :: Nat
one = Succ Zero

two :: Nat
two = Succ (Succ Zero)

three :: Nat
three = Succ (Succ (Succ Zero))

-- Сравнение элементов Nat

eqNat :: Nat -> Nat -> Bool
eqNat Zero Zero = True
eqNat (Succ x) (Succ y) = eqNat x y
eqNat _ _ = False

-- Сложение

add :: Nat -> Nat -> Nat
add Zero y = y
add (Succ x) y = Succ (add x y)

-- Списки

data List a = Nil | Cons a (List a) deriving Show

-- Cons 'a' (Cons 'b' (Cons 'c' Nil)) :: List Char

-- Если команде ghci дать опцию -XGADTs в командной строке или добавить
-- первую строчку, как этом файле, то можно записывать алгебраические типы
-- в следующем виде.

data List' a where
  Nil' :: List' a
  Cons' :: a -> List' a -> List' a

-- Бинарное дерево

data Tree a = Empty | Leaf a | Branches (Tree a) (Tree a) deriving Show

-- Дерево с произвольным конечным количеством детей в каждом узле

data FinTree a = FinNode a [FinTree a]

-- Дерево со счетным числом детей

data InfTree a where
  Leaf' :: a -> InfTree a
  Children :: (Integer -> InfTree a) -> InfTree a

-------------------------------------------------
-- 3. Синонимы типов (type) и обертки вокруг типов (newtype)
-------------------------------------------------

-- Пример из книги Холомьёва, с. 112

-- Синонимы типа

type Velocity = Double
type Time = Double
type Distance = Double

velocity :: Distance -> Time -> Velocity
velocity dist time = dist / time

d :: Distance
d = 10

t :: Time
t = 5

v :: Velocity
v = velocity t d -- не вызывает ошибку несмотря на неправильные единицы

-- Обёртка вокруг типа. Имеет один конструктор, у которого один аргумент.
-- Конструктор имеет значение только при проверке типов и прозрачен во
-- время исполнения.

newtype Velocity' = Velocity' Double
newtype Time' = Time' Double
newtype Distance' = Distance' Double

velocity' :: Distance' -> Time' -> Velocity'
velocity' (Distance' dist) (Time' time) = Velocity' $ dist / time

d' :: Distance'
d' = Distance' 10

t' :: Time'
t' = Time' 5

v' :: Velocity'
-- v' = velocity' t' d' вызывает ошибку
v' = velocity' d' t'

-------------------------------------------------
-- 4. Бинарные операторы
-------------------------------------------------

-- Должны состоять из специальных символов: !#$%&⋆+./<=>?@\^|-~:
-- Не должны начинаться с двоеточия.

-- infix: неассоциативный оператор
-- infixl: левоассоциативный оператор
-- infixr: правоассоциативный оператор

-- Приоритет: от 0 до 9. Чем выше приоритет, тем сильнее связывает
-- оператор. Аппликация имеет наивысший приоритет (даже выше 9).

infixl 6 #

-- Приоритет можно увидеть в интерпретаторе, если дать команду :i (#).

-- Операторы также можно использовать как конструкторы алгебраических
-- типов. В этом случае они наоборот должны начинаться с двоеточия.

infixl 5 :*:

data Foo a b = a :*: b

foo :: Foo Int Bool
foo = 1 :*: True

-------------------------------------------------
-- 5. Объявление классов типов и их экземпляров
-------------------------------------------------

-- Объявим класс Monoid, который является является подклассом Eq.
-- Строго говоря, импликация направлена в другую сторону:
-- если a есть тип класса Monoid, то он также тип класса Eq.
-- См. https://ru.wikipedia.org/wiki/Моноид.

class Eq a => Monoid a where
  (#) :: a -> a -> a
  e :: a

-- Чтобы объявить Nat моноидом, его нужно сначала объявить членом
-- класса Eq. Для этого объявим функцию (==). Её можно определить
-- прямо здесь или заранее, а здесь указать только имя ранее
-- определенной функции.

instance Eq Nat where
  (==) = eqNat
-- Или прямо здесь
-- Zero == Zero = True
-- Succ x == Succ y = x == y
-- _ == _ = False

instance Monoid Nat where
  e = Zero
  (#) = add

instance Monoid Bool where
  e = False
  x # y = x || y

-- Теперь можно писать

nn = one # two
 
bb = True # False

instance Eq a => Monoid [a] where
  e = []
  (#) = (++)
 
double :: Monoid a => a -> a
double x = x # x
  
-------------------------------------------------
-- 6. Домашнее задание 7
-------------------------------------------------

-- 1. Определите умножение на Nat.

-- 2. Объявите Nat членом класса Monoid двумя способами:
-- с операцией сложения и нулём, а также умножения и единицей.
-- Воспользуйтесь обёрткой newtype вокруг Nat.
-- См. Холомьёв, с. 113.

-- Следующий тип определяет арифметические выражения, состоящие из
-- целых чисел, сложения, вычитания и умножения.

data Exp =
  Const Int
  | Add Exp Exp
  | Sub Exp Exp
  | Mul Exp Exp
  deriving Show

-- Например, выражение (5-3)((1+2)+4) представляется

e1 :: Exp
e1 = Mul (Sub (Const 5) (Const 3)) (Add (Add (Const 1) (Const 2)) (Const 4))

-- Чтобы вводить выражения, используя конкретный (обычный), а не
-- абстрактный синтаксис, воспользуемся следующим трюком
-- (Холомьёв, с. 109): объявим Exp членом класса Num. Таким образом
-- можно будет использовать синтаксический анализатор самого Haskell.
-- Минимальное определение членства типа a в классе Num включает
-- в себя определение следующих функций.
-- (+) :: a -> a -> a
-- (-) :: a -> a -> a
-- (*) :: a -> a -> a
-- fromInteger :: Integer -> a
-- abs :: a -> a
-- signum :: a -> a

instance Num Exp where
  (+) = Add
  (*) = Mul
  (-) = Sub
  fromInteger = Const . fromInteger :: Integer -> Exp -- Здесь fromInteger :: Integer -> Int
  abs = undefined
  signum = undefined

-- Теперь вместо e1 выше можно прямо писать

e2 :: Exp
e2 = (5-3)*(1+2+4)

-- 3. Напишите функцию showExp :: Exp -> String, которая выдает
-- инфиксную запись выражения. Каждое подвыражение, кроме констант,
-- должно быть окружено скобками. Например, на выражении выше функция
-- должна выдавать ((5-3)*((1+2)+4)).

-- 4. Зарегистрируйте тип Exp в качестве члена класса Show, используя
-- showExp как реализацию функции show. Проверьте, что выражения,
-- заданные в командной строке, печатаются должным образом.

-- 5. Напишите рекурсивную функцию eval :: Exp -> Int, вычисляющую
-- значение выражения.

-- 6. Напишите рекурсивную функцию applyDistr :: Exp -> Exp, которая
-- применяет законы дистрибутивности (слева) умножения относительно
-- сложения и вычитания:
-- x(y+z) = xy + xz
-- x(y-z) = xy - xz
-- Функция должна за один проход заменять все подвыражения вида
-- x(y ± z) на соответствующую правую часть. Проверьте на примерах,
-- что значение выражения не меняется после применения applyDistr,
-- то есть проверьте, что eval e == eval (applyDistr e)
-- возвращает True на различных выражениях e.

-- 7. Докажите, что функция applyDistr останавливается на любом входе.
