-------------------------------------------------
-- Конспект лекции 2 от 16.02.2023
-------------------------------------------------

-- Содержание

-- 1. Еще про образцы
-- 2. Модули
-- 3. Рекурсия

-- Хорошим введением в Haskell является книга Макеева, ссылка на
-- которую находится на source.unn.ru.

-------------------------------------------------
-- 1. Еще про образцы
-------------------------------------------------

-- Как написать head, tail?
-- Штрих (апостроф) можно использовать в идентификаторах

head' (x : _) = x
tail' (_ : xs) = xs

-- Скобки здесь обязательны, потому что аппликация функции к аргументу
-- связывает сильнее всего.

-- Добавить еще одну голову списка.

addHead :: [a] -> [a]
addHead [] = error "Empty list"
addHead (h : t) = h : h : t

-- Чтобы не повторять h : t, можно сделать так.

addHead' :: [a] -> [a]
addHead' [] = error "Empty list"
addHead' lst@(h : t) = h : lst

-- addHead' [1,2,3] == [1,1,2,3]

-- Принимает двухэлементный список и переставляет эти элементы.
swap :: [a] -> [a]
swap ([x, y]) = [y, x]

-- Никогда не пишите x : []. Вместо этого: [x].
-- Никогда не пишите [x] ++ lst. Вместо этого: x : lst.

-- Образцы можно использовать не только при определении функции, но и в let
-- let (x : xs, 3, y) = ([1, 2, 3], 3, "abc")
-- Чтобы использовать сопоставление с образцом в любом месте,
-- а не только в левой части определения функции или в let и where,
-- нужна конструкция case (см. ниже)

-------------------------------------------------
-- 2. Модули
-------------------------------------------------

-- (Напоминание) Чтобы загрузить модуль Data.List, поместите в начале программы
-- import Data.List

-- В командной строке GHCi можно также сказать
-- :m + Data.List

-- Чтобы выгрузить модуль Data.List в командной строке GHCi
-- :m - Data.List

-- Имена загруженных модулей пишутся в подсказке GHCi.

-- Если функция с одним и тем же именем имеется в двух загруженных
-- модулях (например, в программе и в библиотечном модуле), то GHCi
-- выдает ошибку "Ambiguous occurrence".

-- Чтобы импортировать только функции nub и sort из модуля Data.List:
-- import Data.List (nub, sort)

-- Чтобы импортировать все функции, кроме nub и sort из модуля Data.List:
-- import Data.List hiding (nub, sort)

-- Если нужно переопределить функции из Prelude,
-- поместите следующую строчку в начале файла

-- import Prelude hiding ((^), (^^), even, odd)

-- Теперь можно переопределить функцию из Prelude

-- even n = mod n 2 == 0

-- Чтобы поместить импортируемые функции в другое пространство имен:
-- import qualified Data.List
-- После этого функции будут доступны с префиксом Data.List,
-- например, Data.List.sort.

-- Чтобы поместить импортируемые функции в заданное пространство имен M:
-- import qualified Data.List as M
-- После этого функции будут доступны с префиксом M, например, M.sort.

-- Создание своих модулей

-- Каждый модуль в своем файле
-- Имя модуля = имя файла
-- Расширение файла: .hs

-- Структура файла:

-- module Имя(определение1, определение2,..., определениеN) where
--  
-- import Модуль1(...)
-- import Модуль2(...)
--  
-- определение1
-- определение2
-- ...

-- После Имя идут экспортируемые определения.
-- Остальные определения в модуле могут использоваться только внутри данного модуля.
-- Если после Имя нет скобок, экспортируются все определения.

-- Модуль содержит определения
-- типов
-- значений (в том числе функций)
-- классов типов
-- экземпляров классов типов

-------------------------------------------------
-- 3. Рекурсия
-------------------------------------------------

-- Эта тема хорошо описана в книге Г.А. Макеева на с. 26-41.

-- Следующая функция увеличивает каждый элемент списка на 1.
-- Есть несколько стилей определения функции.

-- Наиболее идиоматичное определение:

inclist [] = []
inclist (x : xs) = x + 1 : inclist xs

inclist1 [] = []
inclist1 xs = head xs + 1 : inclist1 (tail xs)

inclist2 xs = if null xs then [] else (head xs) + 1 : inclist2 (tail xs)

inclist3 l =
  case l of
  [] -> []
  (x : xs) -> x + 1 : inclist3 xs

lngth [] = 0
lngth (_ : xs) = 1 + lngth xs

product' [] = 1
product' (x : xs) = x * product' xs

-- Обращение списка.
-- Нехвостовая рекурсия (результат рекурсивного вызова не является
-- окончательным значением функции), квадратичная временная сложность
-- (почему?).

reverse' [] = []
reverse' (x : xs) = reverse xs ++ [x]

addToEnd :: a -> [a] -> [a]
addToEnd x [] = [x]
addToEnd x (y : ys) = y : addToEnd x ys

-- Можно определить
-- addToEnd x xs = xs ++ [x]

reverse'' [] = []
reverse'' (x : xs) = addToEnd x (reverse'' xs)

-- r [1, 2, 3]
-- a2e 1 (r [2, 3])
-- a2e 1 (a2e 2 (r [3]))
-- a2e 1 (a2e 2 (a2e 3 (r [])))
-- a2e 1 (a2e 2 (a2e 3 []))
-- a2e 1 (a2e 2 [3])
-- a2e 1 [3, 2]
-- [3, 2, 1]

-- В общем случае количество вызовов (:) в addToEnd при обращении списка
-- длины n равно 1 + 2 + ... + n = n(n+1)/2.

-- Хвостовая рекурсия (результат рекурсивного вызова является
-- окончательным значением функции), линейная сложность
-- reverse2 l1 l2 добавляет обращение l1 слева к l2

reverse2 :: [a] -> [a] -> [a]
reverse2 [] ys = ys
reverse2 (x : xs) ys = reverse2 xs (x : ys)

-- Трассировка. Будем писать r2 вместо reverse2
-- r2 [1, 2, 3] [4, 5, 6] =
-- r2 [2, 3] (1 : [4, 5, 6]) =
-- r2 [3] [2, 1, 4, 5, 6] =
-- r2 [] [3, 2, 1, 4, 5, 6] =
-- [3, 2, 1, 4, 5, 6]

rev xs = reverse2 xs []

-- Определения функций foo1 и foo2 ниже выглядят похоже,
-- но есть большая разница в поведении и в сложности.

-- foo1 есть append (конкатенация списков, или ++)

foo1 [] acc = acc
foo1 (x : xs) acc = x : foo1 xs acc

-- foo1 [1, 2, 3] [4, 5, 6] =
-- 1 : foo1 [2, 3] [4, 5, 6] =
-- 1 : 2 : foo1 [3] [4, 5, 6] =
-- 1 : 2 : 3 : foo1 [] [4, 5, 6] =
-- 1 : 2 : 3 : [4, 5, 6] =
-- [1, 2, 3, 4, 5, 6]

-- Контекст (1 : 2 : 3 : _), то есть операция, которую необходимо
-- применить к результату рекурсивного вызова, в терминологии
-- функционального программирования называется продолжением
-- (continuation). Продолжение хранится на стеке, который может
-- переполниться при особенно глубокой рекурсии.

-- foo2 есть reverse

foo2 [] acc = acc
foo2 (x : xs) acc = foo2 xs (x : acc)

-- факториал с нехвостовой рекурсией

fact 0 = 1
fact n = n * fact (n - 1)

-- Факториал с хвостовой рекурсией.

fact1 0 m = m
fact1 n m = fact1 (n - 1) (n * m)

-- fact1 3 5 =
-- fact1 2 15 =
-- fact1 1 30 =
-- fact1 0 30 =
-- 30 = 3! * 5

-- fact1 n m = fact n * m

fact2 n = fact1 n 1

-- Функции с нехвостовой рекурсией часто имеют более естественное
-- определение, но функции с хвостовой рекурсией более эффективны,
-- так как эквивалентны циклам. Преобразование функций первого
-- класса во второй является интересной задачей. Это можно сделать
-- всегда, но не всегда можно достичь экономии памяти, поскольку
-- информацию о рекурсивных вызовах не стеке приходится хранить
-- явным образом.

-------------------------------------------------
-- Решение домашнего задания 1
-------------------------------------------------

-- 6. Напишите функцию Int -> Char, которая переводит цифру в символ.
-- Функция должна вызывать функцию error, аргументом которой является
-- сообщение об ошибке, если аргумент не из отрезка [0..9].

intToChar :: Int -> Char
intToChar 0 = '0'
intToChar 1 = '1' 
intToChar 2 = '2' 
intToChar 3 = '3' 
intToChar 4 = '4' 
intToChar 5 = '5' 
intToChar 6 = '6' 
intToChar 7 = '7' 
intToChar 8 = '8' 
intToChar 9 = '9'
intToChar n = error ("intToChar: " ++ show n ++ " is not a decimal digit")

-- Функцию show возвращает текстовое представление значения, тип которого
-- принадлежит классу Show. Членство в этом классе требует наличие такой функции.
-- Тип Int является членом класса Show. О классах типов будем говорить позже.

intToChar' :: Int -> Char
intToChar' n
  | 0 <= n && n <= 9 = toEnum (n + 48)
  | otherwise = error ("intToChar: " ++ show n ++ " is not a decimal digit")

-- Функция toEnum :: Int -> a определена для типов a из класса Enum.
-- Членство в этом классе требует наличие такой функции.
-- Тип Char является членом класса Enum. О классах типов будем говорить позже.

-- Также есть функции chr, ord в Data.Char

-------------------------------------------------
-- Домашнее задание 2
-------------------------------------------------

-- 1. Напишите функцию, вычисляющую n-ое число Фибоначчи. Используйте
-- стандартное математическое рекурсивное определение и тип Integer,
-- позволяющий работать с целыми числами произвольной величины.
-- Экспериментальным путем найдите n, для которого вычисление занимает
-- больше 10 секунд. Напишите другую реализацию функции с двумя
-- дополнительными аргументами и хвостовой рекурсией. Вычислите 2n-ное
-- число Фибоначчи, где n — номер, найденный выше.

-- 2. Напишите функцию merge :: [Int] -> [Int] -> [Int], которая сливает
-- два упорядоченных списка в один. Например,

-- > merge [2, 5, 6] [1, 3, 4]
-- [1, 2, 3, 4, 5, 6]

-- 3. Напишите функцию halve :: [a] -> [([a], [a])], которая разбивает
-- данный список на две половины, длины которых отличаются не более,
-- чем на единицу. В определении можно использовать стандартные
-- функции. См. особенно функции take, drop и splitAt в описании Prelude.

-- 4. Используя merge и halve, напишите функцию msort :: [Int] -> [Int],
-- реализующую сортировку слиянием. Она разбивает список пополам,
-- рекурсивно сортирует половины и затем сливает в один список. Когда
-- уместно, используйте синтаксические конструкции языка: образцы,
-- ограничения, локальные определения и т.д.
