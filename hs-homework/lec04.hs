import Prelude hiding ((.), flip, curry, uncurry, ($), map, filter)
import Debug.Trace

-------------------------------------------------
-- Конспект лекции 4 от 27.02.2023
-------------------------------------------------

-- Содержание

-- 1. Двумерный синтаксис
-- 2. Бесточечная запись
-- 3. Функции высших порядков
-- 4. Решение задачи из домашнего задания 3
-- 5. Домашнее задание 4

-------------------------------------------------
-- 1. Двумерный синтаксис
-------------------------------------------------

-- Haskell, как и Python, использует величину отступов для определения
-- структуры программы. На самом деле, программу на Haskell можно
-- записать при любом расположении текста, но тогда нужно
-- использовать фигурные скобки и точки с запятой. Так, конструкция
-- let имеет вид

-- let {p1 = e1;  ...; pm = em} in e

-- Чтобы записать ее без скобок, применяются следующие правила. Они
-- относятся к ключевым словам let, where, of (часть выражения case e
-- of) и do (используется для записи монадных вычислений; будем
-- проходить позже). Если первая лексема после этих ключевых слов
-- отлична от {, то есть она является началом выражения p1, то
-- запоминается отступ n перед ней и вставляется неявная открывающаяся
-- скобка. Эта первая лексема может находиться на той же или на другой
-- строчке, и между let и ней может быть любое пустое пространство или
-- комментарии.

-- При рассмотрении каждой следующей непустой строчки определяется
-- отступ перед первой лексемой. Если он больше n, то считается, что
-- продолжается то же равенство p1 = e1, поэтому не вставляется ни
-- точка с запятой, ни закрывающаяся фигурная скобка. Если отступ
-- равен n, то начинается очередное равенство pi = ei, а перед ним
-- вставляется точка с запятой. Если отступ меньше n, то равенства
-- закончились и вставляется закрывающаяся фигурная скобка. Фигурная
-- скобка также вставляется если она возможна на этом месте, а
-- лексема, которая там в действительности находится, невозможна.
-- Неявные закрывающиеся скобки должны соответствовать только неявным
-- открывающимся скобкам.

-- Примеры

-- В f1 полностью расставленные скобки и точки с запятой.

f1 x = let {y = x - 1; z = 2*y} in x + y + z

-- В определении f2 перед y = x - 1 вставляется {, а перед in
-- вставляется }, так как in не может являться продолжением равенства
-- z = 2*y.

f2 x = let y = x - 1; z = 2*y in x + y + z


f3 x = let y = x
                 - 1
           z = 2*x
       in x + y + z

-- В определении f3 первая лексема после let — это y. Это символ номер
-- 12 в строке, то есть отступ перед ней равен 11. Поскольку отступ
-- перед - 1 больше 11, - 1 считается продолжением предыдущего
-- равенства. Поскольку отступ перед z совпадает с отступом перед y,
-- перед z = 2*x вставляется точка с запятой и начитается новое
-- равенство. Поскольку in не может являться продолжением равенства z
-- = 2*x, перед ним вставляется }. Поэтому отступ перед in может быть
-- меньше 11, равен 11 или больше 11.

-- f4 x = let y = x - 1
--              z = 2*x
--        in x + y + z

-- Ошибка: z = 2*x считается продолжением предыдущего равенства y = x - 1.

-- f5 x = let y = x - 1
--          z = 2*x
--        in x + y + z

-- Ошибка: отступ перед z = 2*x меньше, чем перед y = x - 1. Это значит,
-- что равенства закончились и должно идти in, однако это не так.

-- Модуль начинается с записи
-- module Имя(определение1, определение2,..., определениеN) where.
-- Поэтому отступ перед следующим определением задает отступ во всем
-- файле: каждое новое определение должно начинаться с этого отступа.
-- Это верно, даже если используется модуль по умолчанию.

-- Правила для отступов более полно описаны в разделе 2.7 документов
-- "Haskell 2010 Language Report" и "Язык и библиотеки Haskell 98".

-------------------------------------------------
-- 2. Бесточечная запись
-------------------------------------------------

-- Если объявление функции имеет вид

-- f x = expression x -- определение (1)

-- то достаточно написать

-- f = expression     -- определение (2)

-- Поскольку выражения Haskell являются математическими выражениями,
-- для них выполняется закон замены равного равным: если e1 == e2, то
-- e1 можно заменить на e2 в любом контексте. Так, при наличии
-- определения (2) функция f заменяется на expression в выражении f x
-- и получается expression x, то есть эффект определения (2) такой же,
-- как и определения (1).

-- Запись (2) называется бесточечной (безаргументной). Здесь под "точкой"
-- имеется в виду значение, принимаемое функцией, по аналогии с точками
-- топологического пространства. Пример (лекция 1):

-- inc = (+) 1

-- вместо

-- inc x = (+) 1 x

-- Бесточечная запись предлагает думать о функциях и их композициях
-- вместо данных.

-------------------------------------------------
-- 3. Функции высших порядков
-------------------------------------------------

-- Главная особенность функционального программирования состоит в том,
-- что функции являются значениями первого класса. С ними можно делать
-- то же, что и с обычными значениями, такими как числа, символы,
-- булевы значения, списки, кортежи и т.п. Именно, функции можно
-- передавать в другие функции в качестве аргумента, возвращать их из
-- функций, помещать в структуры данных и т.д.

-- Функции, которые принимают или возвращают функции, называются
-- функциями высших порядков. В математике они часто называются
-- функционалами или операторами. Пример: операторы дифференцирования
-- и взятия первообразной. Лекция 3 говорит, что любая функция
-- двух или более аргументов является функцией высшего порядка,
-- потому что она принимает первый аргумент и возвращает функцию.
-- Более существенным проявлением высшего порядка являются
-- функции, которые принимают другие функции в качестве аргументов.

-- Композиция функций f и g обозначается f . g по аналогии с f o g
-- в математике.
-- Joke: you may be a mathematician if you think fog is a composition.

(.)   :: (b -> c) -> (a -> b) -> (a -> c)
f . g =  \x -> f (g x)

-- Следующее определение эквивалентно предыдущему
-- (.) f g          =  \ x -> f (g x)

-- Пример: not . null :: [a] -> Bool проверяет список на непустоту.

-- Другие стандартные фукнции высших порядков

flip        :: (a -> b -> c) -> b -> a -> c
flip f x y  =  f y x

-- Следующее определение эквивалентно предыдущему
-- flip f      =  \x -> \y -> f y x

-- Примеры применения flip

-- Возведение в куб (бесточечная запись)

cube = flip (^) 3
-- cube = (^3)
-- cube = \x -> x^3

-- В Prelude объявлена функция elem :: Eq a => a -> [a] -> Bool,
-- которая проверяет, является ли первый аргумент элементом второго.
-- Тип a должен поддерживать сравнение.

isUpperAlpha :: Char -> Bool
isUpperAlpha x = elem x ['A'..'Z']

-- Альтернативно (бесточечная запись):

-- isUpperAlpha = flip elem ['A'..'Z']

-- Действительно,

-- isUpperAlpha x = flip elem ['A'..'Z'] x = elem x ['A'..'Z']

-- Следующая функция названа в честь Хаскелла Карри, одного из
-- основателей лямбда-исчисления.

curry            :: ((a, b) -> c) -> a -> b -> c
curry f x y      =  f (x, y)

uncurry          :: (a -> b -> c) -> ((a, b) -> c)
uncurry f (x, y)      =  f x y

-- Если через U -> V обозначить множество функций из U в V, а через
-- U x V обозначить декартово произведение U и V, то функции curry и
-- uncurry являются изоморфизмом и его обратным между множествами
-- (A x B) -> C и A -> (B -> C).

map :: (a -> b) -> [a] -> [b]
map f [] = []
map f (x : xs) = (f x) : map f xs

-- map f [x1, ..., xn] = [f x1, ..., f xn]

filter :: (a -> Bool) -> [a] -> [a]
filter p []                 = []
filter p (x:xs) | p x       = x : filter p xs
                | otherwise = filter p xs

-- Альтернативно: filter p xs = [x | x <- xs, p x]

-- map не меняет длину списка, поэтому filter нельзя выразить через map.

-- Пример

-- Пусть есть предикат prime :: Int -> Bool.

-- head (filter prime [100000, 99999..]) есть наибольшее простое число,
-- не превосходящее 100000. Вычисление останавливается после нахождения
-- такого простого числа.

($) :: (a -> b) -> a -> b
($) f x = f x

-- Зачем нужен оператор ($), если он просто выражает аппликацию? Дело
-- в том, что применение функции левоассоциативно и имеет наивысший
-- приоритет. Напротив, оператор $ правоассоциативный и имеет низший
-- приоритет. Поэтому вместо f x (g y (h z)) можно написать
-- f x $ g y $ h z.

-- Пример

-- sum (filter (> 10) (map (*2) [2..10]))

-- можно переписать с меньшим количеством скобок:

-- sum $ filter (> 10) $ map (*2) [2..10]

-- takeWhile :: (a -> Bool) -> [a] -> [a]
-- возвращает наибольший префикс списка, все элементы которого
-- удовлетворяют предикату.

-- takeWhile (/= ' ') "Первое слово в предложении" => "Первое"

-------------------------------------------------
-- 4. Решения некоторых задач из домашнего задания 3
-------------------------------------------------

-- 1. Используя генератор списков, напишите функцию powerset :: [a] ->
-- [[a]], которая возвращает список всех подсписков данного списка.
-- Порядок элементов в возвращаемых списках неважен.

powerset [] = [[]]
powerset (x : xs) = let p = powerset xs in p ++ [x : s | s <- p]

-- Вместо [x : s | s <- p] можно написать map (x :) p.

-- Идея: в предположении, что powerset [2, 3] == [[], [2], [3], [2, 3]] имеем:
-- powerset [1, 2, 3] == [[], [2], [3], [2, 3]] ++ [[1], [1, 2], [1, 3], [1, 2, 3]]

-- 3. Определение minimum через msort.
-- msort создает бинарное дерево рекурсивных вызовов. Если msort xs
-- вызывает msort l1 и msort l2, где l1 ++ l2 == xs, то результаты
-- этих вызовов объединяются с помощью merge. Для того, чтобы получить
-- голову результата merge (а именно этого достаточно для вычисления
-- минимума в силу ленивой стратегии вычислений), функция merge должна
-- сделать одно сравнение. Таким образом, количество сравнений равно
-- числу внутренних вершин в дереве рекурсивных вызовов msort.

-- Легко доказать индукцией по бинарному дереву, что количество
-- листьев превосходит количество внутренних вершин на 1.
-- Действительно, дерево — это либо лист, либо корень с двумя
-- поддеревьями. В первом случае утверждение верно. Пусть два
-- поддерева имеют соответственно l1 и l2 листьев и i1 и i2 внутренних
-- вершин. По предположению индукции l1 = i1 + 1 и l2 = i2 + 1.
-- Количество листьев в целом дереве есть l1 + l2, а количество
-- внутренних вершин — i1 + i2 + 1 (нужно добавить корень дерева).
-- Таким образом, требуемое утверждение l1 + l2 = (i1 + i2 + 1) + 1
-- имеет место и для целого дерева.

-- Листья в дереве рекурсивных вызовов соответствуют вызовам msort на
-- одноэлементных списках, поэтому количеству листьев равно длине
-- списка, являющегося аргументом функции minimum. Значит, данная
-- реализация функции minimum делает n-1 сравнений на списке длины n,
-- как и любая другая оптимальная реализация.

-- Убедиться в этом можно с помощью функции trace :: String -> a -> a,
-- которая находится в модуле Debug.Trace. Функция trace печатает
-- свой первый аргумент и возвращает второй. Функцию merge из lec03.hs
-- можно переписать следующим образом.

halve xs = splitAt (div (length xs) 2) xs

merge :: Ord a => [a] -> [a] -> [a]
merge [] ys = ys
merge xs [] = xs
merge l1@(x : xs) l2@(y : ys)
  | x < y = x : merge xs l2
  | otherwise = y : merge l1 ys

-- merge :: (Show a, Ord a) => [a] -> [a] -> [a]
-- merge [] ys = ys
-- merge xs [] = xs
-- merge l1@(x : xs) l2@(y : ys)
--   | trace (show x ++ " " ++ show y) False = undefined
--   | x < y = x : merge xs l2
--   | otherwise = y : merge l1 ys

msort :: (Show a, Ord a) => [a] -> [a]
msort [] = []
msort [x] = [x]
msort xs =
  let (l1, l2) = halve xs in
    merge (msort l1) (msort l2)

-- Таким образом, каждый раз, когда два числа сравниваются, они печатаются.

-- 3.4

regLengths :: [(Integer, Integer)] -> [Integer]
regLengths [] = []
regLengths ((a, d) : seqs) = merge [a, a+d ..] (regLengths seqs)

-- 3.5. Напишите функцию primes :: [Integer], которая вычисляет бесконечный
-- список простых чисел с помощью алгоритма "Решето Эратосфена".

primes :: [Integer]
primes = sieve [2..]
  where sieve (p : xs) = p : sieve [p' | p' <- xs, p' `mod` p /= 0]

-- Можно слегка оптимизировать функцию, начав со списка нечетных чисел.

primes1 :: [Integer]
primes1 = 2 : sieve [3,5..]
  where sieve (p : xs) = p : sieve [p' | p' <- xs, p' `mod` p /= 0]

-------------------------------------------------
-- 5. Домашнее задание 4
-------------------------------------------------

-- 1. Прочитайте документацию по модулям Prelude и Data.List,
-- пропуская непонятные части. Цель — познакомиться с набором функций
-- в стандартной библиотеке.

-- 2. Объясните, почему функции в каждой паре совпадают.

-- (1) \x y -> x + 1  и  const . (+ 1)
-- (2) \x y = y x  и  flip id

-- Функция id определена в Prelude следующим образом.

-- id   :: a -> a
-- id x = x

-- Как функция const . (+ 1) действует на число x?
-- x |-> x + 1 |-> \y -> x + 1

-- flip f = \x y -> f y x
-- flip id = \x y -> id y x = \x y -> y x

-- 3. Объясните, почему map (f . g) == map f . map g.

-- map (f . g) [x1 ... xn] = [(f . g) x1 ... (f . g) xn] = [f (g x1) ... f (g xn)].
-- (map f . map g) [x1 ... xn] = map f (map g [x1 ... xn]) = map f [g x1 ... g xn] =
-- = [f (g x1) ... f(g xn)].

-- 4. Что делают следующие два определения?

listOfFuns = map (*) [0..]

applyAll x = take 10 (map ($ x) listOfFuns)

-- 5. Напишите функцию iter :: (a -> a) -> Integer -> (a -> a),
-- такую что iter f n x = f (f (... (f x)...)) (f используется n раз, n >= 0).
-- Замените undefined на правильные выражения.

iter f 0 = id
iter f n = f . iter f (n-1)

-- iter f 3: x |-> f (f (f x))
-- Нужно:    x |-> f (f (f (f x)))

-- iter можно также определить с помощью следующей функции из Prelude.

-- iterate :: (a -> a) -> a -> [a]
-- iterate f x == [x, f x, f (f x), ...]

-- Тогда

-- iter f n x = iterate f x !! n

-- 6. Дана функция

next :: Int -> Int
next x
  | x `mod` 2 == 0 = x `div` 2
  | otherwise = 3 * x + 1

-- Итерация функции next генерирует последовательность Коллатца.
-- См. "Гипотеза Коллатца" в Википедии и https://xkcd.com/710.

-- С помощью функций iterate, takeWhile и length из Prelude напишите
-- функцию collatzLength :: Int -> Int, такую что collatzLength n
-- возвращает длину последовательность Коллатца, начинающуюся c n и
-- заканчивающуюся 1. Гипотеза состоит в том, что collatzLength
-- определена на всех натуральных числах.

-- Напишите функцию longCollatz :: Int -> Int -> Int -> Int, такую что
-- longCollatz a b n возвразает количество последовательностей Коллатца,
-- начинающихся с чисел от a до b включительно и имеющих длину не меньше n.
-- Для этого можно сделать следущее.
-- (1) Найти список l натуральных чисел от a до b.
-- (2) Для каждого элемента l вычислить длину последовательности, которая
-- начитается с этого элемента.
-- (3) Из полученного списка длин оставить элементы >= n.
-- (4) Найти длину оставшегося списка.
