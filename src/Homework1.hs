module Homework1 where

import Data.Char

-------------------------------------------------
-- 6. Домашнее задание 1
-------------------------------------------------

-- 1. Установите Haskell. +

-- 2. Прочитайте конспект лекции и определите, что делают описанные
-- функции (take, replicate и т.д.), опираясь на их имя, тип и примеры
-- использования. Можно также смотреть документацию по следующим
-- ссылкам.
-- http://haskell.ru/standard-prelude.html
-- https://hackage.haskell.org/package/base-4.16.0.0/docs/Prelude.html +

-- 3. В Haskell есть две функции для целочисленного деления: quot и
-- div, а также две функции для взятия остатка: rem и mod. Как
-- отличается их поведение, когда один из аргументов является
-- отрицательным числом? +

-- В Haskell функции для целочисленного деления и взятия остатка работают следующим образом:

-- quot:
-- Функция quot выполняет целочисленное деление, игнорируя знак чисел и возвращая результат, округленный в сторону нуля.
-- Если оба числа положительные, результат будет таким же, как при делении на цело в математике.
-- Если одно или оба числа отрицательные, результат будет округлен в сторону нуля, что может отличаться от поведения в других языках программирования.
-- div:
-- Функция div также выполняет целочисленное деление, но сохраняет знак результата, округляя к нулю.
-- Если оба числа положительные, результат будет таким же, как при делении нацело в математике.
-- Если одно или оба числа отрицательные, результат будет округлен к нулю, но знак результата будет соответствовать знаку делимого.
-- rem:
-- Функция rem возвращает остаток от деления, сохраняя знак делимого.
-- Остаток от деления отрицательного числа на положительное также будет отрицательным.
-- mod:
-- Функция mod также возвращает остаток от деления, но сохраняет знак делителя.
-- Остаток от деления отрицательного числа на положительное будет положительным.
-- Короче говоря, различие между quot и div заключается в обработке знаков отрицательных чисел. Аналогично, rem и mod различаются в том, как они обрабатывают знаки делителя и делимого при вычислении остатка.

-- 4. Напишите функцию типа Float -> Float -> Float -> Float, которая
-- вычисляет наименьший из корней уравнения |x - a| + |x - b| = c,
-- если он существует. +

solveEquation :: Float -> Float -> Float -> Float
solveEquation a b c
    | c < 0     = error "No real roots exist for this equation"
    | c == 0    = min a b
    | otherwise = (a + b) / 2 - c / 2

-- 5. Напишите функцию Integer -> Integer вычисляющую произведение
-- последних трех десятичных цифр числа.

productLast3Digits :: Integer -> Integer
productLast3Digits n = let last3Digits = n `mod` 1000
                       in product $ map (`mod` 10) $ take 3 $ iterate (`div` 10) last3Digits

-- last3Digits = n mod 1000: Здесь мы используем оператор mod для получения последних трех десятичных цифр числа n.
-- take 3 $ iterate (div 10) last3Digits: Мы используем функцию iterate для создания бесконечного списка, где каждый следующий элемент получается путем деления предыдущего элемента на 10. Затем мы берем первые три элемента этого списка, используя take 3. Это дает нам список, содержащий последние три десятичные цифры числа.
-- map (mod 10) ...: Мы применяем функцию (mod 10) ко всем элементам списка, чтобы получить последние десятичные цифры каждого элемента.
-- product ...: Затем мы находим произведение всех элементов списка, используя функцию product.

-- Решено на занятии.

-- Функция show переводит значение в его текстовое представление,
-- то есть строку.

-- Функция digitToInt определена в модуле Data.Char, который импортируется
-- в начале файла.

productLast3 :: Int -> Int
productLast3 n =
  let s = show n
      len = length s
      [x1, x2, x3] = drop (len - 3) s
   in digitToInt x1 * digitToInt x2 * digitToInt x3

productLast3' :: Integer -> Integer
productLast3' n = n1 * n2 * n3
  where
    n1 = n `mod` 10
    m = n `div` 10
    n2 = m `mod` 10
    n3 = m `div` 10 `mod` 10

-- 6. Напишите функцию Int -> Char, которая переводит цифру в символ.
-- Функция должна вызывать функцию error, аргументом которой является
-- сообщение об ошибке, если аргумент не из отрезка [0..9].

-- Решено на занятии.

intToChar :: Int -> Char
intToChar 0 = '0'
intToChar 1 = '1'
intToChar 2 = '2'
intToChar 3 = '3'
intToChar 4 = '4'
intToChar 5 = '5'
intToChar 6 = '6'
intToChar 7 = '7'
intToChar 8 = '8'
intToChar 9 = '9'
intToChar _ = error "Out of range"

intToChar' :: Show a => a -> Char
intToChar' n = head (show n)

intToChar'' :: Show p => p -> Char
intToChar'' n = let [c] = show n in c

n :: Int
n = mod 1 2
