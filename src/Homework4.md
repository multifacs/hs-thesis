# Домашняя работа 4

### Задание 2

- `\x y -> x + 1` и `const . (+ 1)`: Обе эти функции берут два аргумента `x` и `y`, но возвращают `x + 1`.
    - В первой функции `\x y -> x + 1`, мы явно указываем, что возвращаемое значение равно `x + 1`, независимо от значения `y`.
    - Во второй функции `const . (+ 1)`, `const` - это функция, которая принимает два аргумента и всегда возвращает первый аргумент, игнорируя второй. Таким образом, `(const . (+ 1))` композирует функцию `(+ 1)` с функцией const, причем `(+ 1)` применяется первым, а `const` - вторым. Когда мы применяем эту композицию к двум аргументам `x` и `y`, то `(const . (+ 1)) x y` эквивалентно `const ((+ 1) x) y`, что в свою очередь равно `(+ 1) x`, то есть `x + 1`.

    В итоге, обе функции возвращают `x + 1`, их поведение одинаково.
 - `\x y = y x` и `flip id`: Обе эти функции также берут два аргумента `x` и `y`, но возвращают `y x`.
    - В первой функции `\x y = y x`, мы просто применяем `y` к `x`, то есть результатом будет `y x`.
    - Во второй функции `flip id`, `flip` - это функция, которая принимает другую функцию `f` и возвращает новую функцию, которая принимает два аргумента, но применяет их в обратном порядке к функции `f`. В данном случае, `id` - это функция, которая возвращает свой аргумент, так что `flip id` просто меняет местами аргументы. Таким образом, `flip id` применяется к `x` и `y`, что эквивалентно `id y x`, что равно `y x`.

    Опять же, обе функции возвращают `y x`, их поведение совпадает.

Разберем, как функция `const . (+ 1)` действует на число `x`.

Сначала рассмотрим, как действует функция `(+ 1)` на число `x`. Функция `(+ 1)` принимает число и прибавляет к нему `1`. Таким образом, если мы применим `(+ 1)` к числу `x`, мы получим `x + 1`.

Теперь, композиция функций `const . (+ 1)`.

Функция `const` принимает два аргумента и всегда возвращает первый, игнорируя второй.

Таким образом, `(const . (+ 1))` применяет `(+ 1)` первым, а const вторым.

После применения `(+ 1)` к `x`, мы получаем `x + 1`. Затем `const` игнорирует второй аргумент и возвращает `x + 1`, независимо от значения второго аргумента `y`.

Итак, если мы рассмотрим действие функции `const . (+ 1)` на число x, мы получим функцию `\y -> x + 1`. Эта функция просто возвращает `x + 1`, игнорируя аргумент `y`.

### Задание 3

- `map (f . g) [x1, ..., xn]`:
    - Эта функция сначала применяет композицию `f . g` к каждому элементу списка, что приводит к результату `[f (g x1), ..., f (g xn)]`.
- `map f . map g [x1, ..., xn]`:
    - Эта функция сначала применяет функцию map g к списку, что приводит к результату `[g x1, ..., g xn]`.
    - Затем она применяет функцию `map f` к этому результату, что приводит к результату `[f (g x1), ..., f (g xn)]`.

Таким образом, обе функции дают одинаковый результат: `[f (g x1), ..., f (g xn)]`.

Это происходит потому, что композиция функций и операция map обладают свойством ассоциативности, то есть порядок применения функций не важен.

### Задание 4

- `listOfFuns = map (*) [0..]`:Это определение создает список функций, каждая из которых умножает свой аргумент на число из списка `[0, 1, 2, ...]`.Например, `listOfFuns !! 3` представляет собой функцию, которая умножает свой аргумент на 3.
- `applyAll x = take 10 (map ($ x) listOfFuns)`:Это определение создает функцию `applyAll`, которая принимает один аргумент `x`. Внутри функции применяется следующий процесс:
    - `map ($ x) listOfFuns` применяет каждую функцию из `listOfFuns` к аргументу `x`. Оператор `($)` применяет функцию к аргументу, и `map ($ x) listOfFuns` создает список результатов применения каждой функции из `listOfFuns` к `x`.
    - `take 10` берет первые 10 элементов из списка результатов применения функций.

Таким образом, `applyAll x` возвращает список первых 10 результатов применения функций из `listOfFuns` к аргументу `x`. Например, если `x` равно 5, то `applyAll 5` вернет список первых 10 элементов последовательности `5 * 0, 5 * 1, 5 * 2, ...`.